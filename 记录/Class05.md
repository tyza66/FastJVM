# Native，方法区

### Native

1. 创建线程的时候，那个start方法进去发现运行的逻辑仅仅是判断当前线是不是新生的添加进线程组里面，判断线程是否已经启动，如果没有就调用start0方法

   ```java
   private native void start0();
   ```

2. 在一个class里面定义了一个这样像接口中抽象方法一样的方法，十分诡异

3. 这个东西自己写也不会报错 主要是那个native关键字 但是是不能被执行的 交给谁去执行是一个问题

4. 凡是带了native关键字的方法，说明java的作用范围达不到了，会去调用底层c语言的库

5. 这个其实就是之前的结构中的本地方法接口（Java Native Interface，JNI，本地方法接口）

6. 凡是带了native的方法，会进入本地方法栈

7. 调用了本地方法栈里面的方法，java不能执行，去找JNI接口，去调用本地方法接口

8. 本地方法库就是为了拓展java的功能

9. 本地方法接口是公开的，也可以自己写

10. JNI 的作用就是扩展java的使用，融合不容的编程语言为java所用

11. java诞生的时候c，c++横行，所以说当时想要立足就必须要有调用c和c++的代码

12. 它在内存区域中专门开辟了一块标记区域 叫做Native Method Stack（本地方法栈） 只有登记没有执行 在最终执行的时候通过JNI去加载本地方法库中的方法

13. 现在native使用的越来越少了，除非主要写的东西与硬件有关，操作硬件，驱动本地的东西（比如打印机）

14. 在企业级应用中较为少见，掌握即可

15. 调用其他接口：多种通信协议（http，socket，webservice）

### PC寄存器

1. Program Counter Register 程序计数器
2. 每一个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用于存每一条指令的地址，还有即将要执行的指代码），在执行引擎读取到下一条指令，是一个非常小的内存空间，几乎可以忽略不计。

### 方法区

1. 方法区是被所有线程共享的，一些特殊方法，构造方法，接口等也在此定义，简单说就是所有定义的方法的信息都存在这个区域，此区域属于共享区间。
2. 静态变量，常量，类信息（构造方法，接口定义），运行时的常量池存在方法区中，但是实例变量存在对内存中，与方法区无关。
3. 常量池在方法区里面
4. 比如我们定义一个类，里面的成员有一些默认值，这些默认值会存在常量池里面，如果没给这些成员赋值，就会从常量池里面直接拿默认的。
5. static，final，class模板，常量池
6. 面试有时候让画类对象的产生过程